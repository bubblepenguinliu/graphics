第 2 章 Loop 曲面细分

Loop 曲面细分这个实验中，你将细分一个三角形网格，从而得到更精细、光滑的模型。

2.1 实验内容
理解 Loop 曲面细分的基本原理和适用条件，完成对封闭流形网格的曲面细分操作。

2.2 指导和要求
2.2.1 曲面细分
问题 2.1 曲面的表示形式
　　我们测量或设计一个物体时只能描述有限的点，而物体的表面经常是光滑的曲面，这就带来一个问题：如何用有限的点描述一个光滑曲面？
解 良好的描述方法应该满足：
曲面的形状应该和给定的点有直观联系，曲面“看起来”就是由这些点决定的。从微分学角度，曲面有一定的连续性，比如导数连续或者曲率连续。
如果修改某个点的位置，最好只影响这个点周围区域曲面的形状，而不导致整个曲面变形。
而 B 样条曲面就能满足这些要求。
曲面比较复杂，我们先从曲线说起。

图 2.1: 一条由八个点控制的四阶 B 样条曲线

　　根据课上学到的知识，B 样条曲线只要达到三阶就是 C1 连续的（处处可导），并且挪动控制点只修改邻近部分曲线的形状，很适合用来作图。
那么曲面呢？想象一组同阶 B 样条曲线，每一条都有相同个数的控制点。我们知道，B 样条曲线是由参数
方程 p = Σn	p Bi,k(t), t ∈ [a, b] 描述的，一个参数值 t 对应曲线上的一个点，一组曲线上就有一组点。用这
i
一组点作控制点，又可以得到一条B 样条曲线。当 t 取遍[a, b] 上的所有值时，这条曲线扫过的就是一个B 样条曲面。
一个方向 k 阶、另一个方向 l 阶的 B 样条曲面参数方程是：

m	n
p = Σ Σ pi,jBi,p(u)Bj,l(v)
i=1 j=1



		
图 2.2: 从不同视角观察一个 B 样条曲面及其控制点

　　图形学以处理三角形网格为主，相应的 B 样条曲面也是定义在仿射坐标系上的，形式和上面的方形网格一致。表示和计算这样的基函数都有点麻烦，拟合就更麻烦了。
　　回忆一下，B 样条基函数 Bi,k(t) 是递归定义的，图 2.3 中蓝色的低阶基函数线性组合得到橙色的高阶基函数。

图 2.3: 一至三阶的 B 样条基函数
问题 2.2 更简单的计算方法
　　既然最终渲染的通常是直线段而非曲线，那么曲线（曲面）本身不过是一种中间表示罢了。是不是有更简单的方法，可以不经过拟合就求出 B 样条曲线（曲面）的离散近似呢？
解 答案是有的，这就是细分曲线（曲面）。
　　像图 2.4 这样的折线，如果我们想把它的“棱角”打磨得光滑一些，很自然的想法是把凸起的角切平，从而产生更多的线段（边）。

图 2.4: 一条随意的折线

　　不断重复“把角切平”的过程，就会让多边形越来越光滑。重复的次数趋于正无穷时，直观上就能想象到结果会趋近于一条光滑曲线。
“切角”的数学描述就是增加顶点和边。图 2.5 所示的迭代过程中，新顶点的位置是相邻顶点的线性组合。借


助矩阵特征根可以证明，迭代结果收敛到三次 B 样条曲线。类似地，用合适的方法给三维网格“切角”，就能任意逼近 B 样条曲面。


图 2.5: 细分操作的迭代过程

　　细分网格比细分折线要麻烦不少，因为折线可以是一个有序点列，网格顶点却是不能排序的，这产生了复杂的邻接关系和拓扑结构。Loop 细分是一种细分三角网格的方法，可以将任意三角网格细分逼近到网格顶点控制的双向四阶 B 样条曲面 [3]（C2 连续，也就是导函数处处连续）。
Loop 细分的过程有两步：
1. 将每个三角形三边中点连起来，从而将它划分成四个新三角形。（产生了三个新顶点和三条边）

图 2.6: 4-1 细分

2. 调整所有顶点的位置，从而改变网格的形状。

图 2.7: 计算新坐标时各顶点的权重

顶点分为两种：第一步新增的顶点和网格原有的顶点。图 2.7 中实线表示原有的边，虚线表示新增的边。红色顶点是待调整顶点，调整后它们的坐标都是周围顶点旧坐标的线性组合，权重如图所示。
计算新增顶点的坐标时，相邻的顶点影响大，相对的顶点影响小：


vnew =

3
8 (v1 + v2) +

(v3 + v4)	(2.1)
8



原有顶点的坐标则根据其邻接顶点数 n 调整：

vnew = (1 ? nu)vold + u


Σ vneighbor	u =

???  3 
???  3 




if n = 3

else




(2.2)

在一个三角网格上重复这个过程，网格就会变得越来越光滑，趋近于以这个网格为控制点的 B 样条曲面。
问题 2.3 顶点权重
如果调整顶点坐标时，把权重系数换一换会发生什么结果？
解 某些权重可能导致细分后产生大量尖锐凸起，并且还有一定的自相似性，也就是导向了分形；另一些则可能导致网格越分越小，最后无限趋近于一个点。正确的Loop 细分虽然也会导致缩小，但缩小过程是有限的。类似的现象在二维情况（细分曲线）下比较容易证明，有兴趣的同学可以自学 GAMES 102 课程?? 8 讲。

2.2.2 网格的整体性质：封闭与流形


　　简单起见，我们先讨论封闭流形三角网格。直观来看，就是表面平整、没有毛刺和空洞的网格。这种网格还有两个很有用的性质：
性质 封闭流形三角网格的性质所有面片都是三角形
每个顶点至少有三个邻接顶点
　　上面的定义和性质保证了我们进行 Loop 细分第二步时，只有图 2.7 所示的两种可能性，而使用式 2.2 调整原有顶点坐标时不会出现 n < 3 的情况。
　　再考虑更普适一些的问题：如果某个网格是不封闭的，那么式 2.1 和式 2.2 都不再合适了1。处理边界顶点时，我们需要使用另外的权重公式：

??vnew = 1 (v1 + v2)	for generated vertices
?vnew = 3 vold + 1 (v1 + v2)  for existing vertices


(2.3)

　　式 2.3 中的 v1, v2 都表示边界上的两个相邻顶点。如果你对更实用的 Loop 细分算法（允许指定某些边完全不变形）感兴趣，可以阅读 C. Loop 的论文原文 [3]。

2.2.3 实现思路和细节
曲面细分是一个全局操作，实现它需要遍历所有顶点（或边、面片等），但之前我们并没有提到应该怎么做。
　　Dandelion 将每一种基本元素存储于一个双链表中，双链表类型的说明请参考开发者文档：LinkedList。要遍历一个双链表中的元素，我们就要沿着  next_node 指针移动：

1会导致细分后网格边界收缩，建议自己动手尝试一下




遍历边或面片的过程非常接近，只要改为遍历  edges 或  faces 即可。解决了遍历问题，接下来就是实现 4-1 细分和位置调整这两步了。
问题 2.4 4-1 细分的实现
　　不知道大家有没有自己考虑过：新增顶点和边的操作怎么完成？如果想要按照之前介绍的那样一步将每个三角形分成四个小三角形（也称为 4-1 细分），就会带来两个问题：
每个三角形细分前后总共涉及 12 条半边、6 个顶点、9 条边和 4 个面，这么多元素操作起来非常容易混乱。边是两个面片共享的，因此中点也是共享的。细分一个三角形会让一条边变成两条边，这会导致相邻的未细分面片不再是三角形（虽然形状不变，但它可能有四条、五条或者六条边）。
解 为了更容易地实现细分，我们稍微修改一下细分流程，将 4-1 细分的过程再分成两步：
1. 将每条原有的边从中点分裂成两条边，并将新顶点（中点）与相对位置的顶点之间新增一条边。
2. 旋转所有??一步新增的边（连接新、旧顶点的新增边）。

图 2.8: 修改后的 4-1 细分流程

 笔记 在封闭网格中，一条边必然被两个三角形共享，但图 2.8 中我们只画出了一个三角形。在实现分裂操作时，这条边两侧的两个三角形都要分裂，而不能只分裂一个。换言之，一次分裂操作需要将一条边分裂成两条边、将两个三角形各自分裂得到四个三角形。
对照图 2.8 就比较容易理解为什么这样做能实现 4-1 细分：
我们每次分裂的总是蓝色边（旧边），并且总是把一个三角形面分成两个三角形面。当一个三角形面的三条旧边都被分裂之后，必然是第三或第四幅图中的样子。
第三幅图翻转一条红色边 (Edge Flip) 后必然能转化为第四幅图。
编写代码时请注意如下两点：
分裂所有旧边的过程中，不要再次分裂分裂后的边，这会导致无限分裂的死循环。翻转的一定是新边，不要翻转旧边，这会导致网格形状错误。
　　 Edge 类型有一个  bool 属性  is_new 用于标识新旧，但上面两点中所需要区分的边其实有三种（分裂前的旧边、分裂后的旧边、新边）。请大家自己安排合适的实现方式，尤其注意不要混淆分裂后的旧边和新边。
在局部操作（实验 2.7）中，你已经实现了翻转和分裂操作，可以直接用在本次实验中。

2.2.4 调试
　　我们之前已经讲过输出日志，也同样鼓励你在实现Loop 细分时输出级别合适的日志。除此以外，这里再介绍一个检查工具  HalfedgeMesh::validate 函数。这个函数检查半边网格是否合法（是否保持流形、半边指针是否出错），每完成一步处理，都可以调用它进行检查。如果检查出了问题，它会以 error 级别输出日志指

2.3 提交和验收

出错误内容。
　　在实现算法后，你可以执行 Loop Subdivision 这个单元测试来判断自己的实现是否正确。这个单元测试使用几个相对简单的例子来测试，通过比对细分后的 mesh 与参考答案来判断正确与否。但这个测试并未包含不封闭的 mesh ，最终得分仍然需要通过验收。

2.2.5 要求
　　本实验需要填写 geometry/meshedit.cpp 中的  HalfedgeMesh::loop_subdivide 函数。填写完成后加载 cube.obj 进入建模模式，点击 Loop Subdivide 按钮即可进行一次细分。图 2.9 展示了连续进行三次细分的结果，可以看到物体缩小、表面逐渐光滑。

图 2.9: 对立方体进行迭代细分

　　你需要继续加载 cow.dae 和 bunny_hole.dae 进行细分，验证程序的正确性。注意边界同样需要被细分，或者说边界边同样需要被分裂（分裂出的顶点坐标根据式 2.3 计算）。

2.3 提交和验收
要提交的结果截图有三张：细分四次的 cube.obj、细分两次的 cow.dae 和细分一次的 bunny_hole.dae。
　　所有的细分测试必须依次完成，中途只允许删除物体（选中后按 delete 键）不能退出程序，因此日志文件中应当包含全部细分过程输出的日志。测试时日志级别设置为 debug 。
验收时需要现场演示细分操作，正确实现 4-1 细分可以得到 5 分，正确调整顶点位置可以再得到 3 分，共计
8 分。








